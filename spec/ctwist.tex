\documentclass[a4paper,11pt]{article}

\usepackage{listings}
\lstset{basicstyle=\ttfamily,numbers=left,numberstyle=\tiny,}

\usepackage{verbatim}

\newcommand{\tcode}[1]{\texttt{#1}}

\title{The CTwist, a Twisted C Language and Library Specification to take programming to infinity}
\date{in progress}
\author{Ruben Van Boxem}

\begin{document}

\maketitle

\newpage

\tableofcontents
\thispagestyle{empty}
\newpage

\section{Introduction}

CTwist, aka Twisted C, is a language inspired by the rich featureset of C++.
It is an attempt to simplify most incredibly daft points in the currect C++ language, clone the most useful features, and improve those features that were badly or nonuniformly designed.
Although the aim is feature parity or even expansion, the syntax will be radically different in order to simplify the compilation process and improve the readability of previously written code.
Not only will the library’s interface be more uniform, the archaic C standard library will be placed outside of CTwist’s world, being only callable as a foreign interface, if you really have no alternative.
The Twisted C Standard Library will replace all necessary functionality contained in the C Standard library, ensuring a uniform callable interface without mixing inherent language style and intent.
A shortlist of the most prominent features of Twisted C are listed below.

\begin{itemize}
  \item Strong, static typing,
  \item Inheritable fundamental types,
  \item Strong typedefs,
  \item Classes,
  \item Parametric polymorphism for functions and user-defined types,
  \item Low level memory access (raw read-write to arbitrary memory locations),
  \item Exceptions,
  \item No pre-processor,
  \item ABI standardization (to the level of CTwist object code, different OSes enforce different low-level ABI’s CTwist cannot change),
  \item Unicode support, inside and out,
  \item Integrated multithreading in basic language constructs,
  \item A large Standard library, including a lot of functionality that has been wrapped over and over by different C and C++ libraries like Boost, Qt, etc...
  \item JIT execution of code through LLVM's JIT capabilities,
  \item Type inference?
  \item User-defined operators?
  \item Integrated documentation generation (to replace readable headers)?
\end{itemize}
Example programs with a tutorial-like explanation can be found in section \ref{sec:examples}, displaying typical syntax to express common programming constructs.

\section{Files and environment}

In an attempt to bring order to the chaos that C-like languages face and cause a lot of grief for programmers, CTwist defines the following strict rules to be followed in all files involved in CTwist source and object code.

  \subsection{Source files}

Source files will be encoded in UTF-8 to avoid byte order issues or obsolete system encodings being used.
Both \verb \ \tcode{n} and \verb \ \tcode{r} \verb \ \tcode{n} will be valid and must be accepted interchangeable by the compiler (different files may have different line endings, one line ending type per file).
\\ ...

  \subsection{Binary files}

Binary files can take two forms: native and intermediate.
Native files contain only architecture/OS-native code that can be executed or loaded by the targetted OS.
They are meant for end-user execution, not development.
Intermediate files are still platform-independent and contain a platform-independent compiled representation of the source code.
These are meant to be used for development, and provide a means to quickly test minor changes without recompiling and linking everything.
A combination of both is possible as well, and handy only for increasing development speed (optimizations can be done once, and the resulting code is reused from then on).
So "native" and "intermediate" only affects the type of compiled code, and does not say anything about generic code presence.

  \subsection{Native Binaries}

Native binaries do not contain generic code.
Examples include executables, Windows DLL's, Linux' \tcode{.so} files, Mac OS X' \tcode{.dylib} files.
In general, these binary files only depend on core OS components, and any Twisted C libraries they use.
Optionally, legacy C code can be linked in through a compatibility interface \ref{sec:c_compatibility}, which is also used to call into OS APIs in a transparent fashion.

  \subsection{Intermediate files}

Intermediate files contain everything the CTwist compiler needs to generate native binaries.
Nothing prevents an implementation to only provide a compiler AST representation in an intermediate file.
This will allow for all forms of syntax and well-formedness checking, but is a bit inefficient to debug exection (code will have to be generated over and over).
Along with AST representation of code, LLVM bytecode of non-generic constructs can be present.
This bytecode can be pre-optimized, to increase the code generation phase. 

  \subsection{Hybrid files}

Hybrid files contain non-native code and 

  \subsection{Compilation model}
    \subsubsection{Phases of translation}

Translation is the process in which a CTwist compiler converts source code input into a Twisted Object file or 

    \subsubsection{Reference implementation}

The reference compiler is implemented on top of the LLVM infrastructure, and therefore the reference compilation model will base itself upon the LLVM bytecode representation, which is a flexible and platform-independent compiled and perhaps optimized intermediary representation, allowing for easy link-time optimization (through LLVM machinery).
Alongside the LLVM bytecode, there will be a binary representation of “generic” code, necessary to provide C++ template functionality without a “header” concept.
Essentially, a compiled “Twisted Object” file will consist of the following:
\begin{itemize}
  \item Binary (compiler) representation of functions and classes declarations, including the defini (the compiler’s Abstract Syntax Tree)
  \item Symbol table to match the declarations to the LLVM bytecode.
  \item LLVM bytecode for non-generic functions and fully specialized generic functions.
\end{itemize}
The binary representation will be in such a form that it can be quickly loaded by the compiler when needed.
It contains all information needed to resolve parametric polymorphic resolution, both for functions and classes.
The binary representation will be open and fully specified, with reference tools to verify and test the validity.
\\ ...

\section{Program structure}
  \subsection{Introductory note}


  \subsection{Entry point}

Any Twisted Object file can contain a formal \emph{entry point}.
The result is that multiple Twisted Objects with entry points defined can be linked together. 

\section{C compatibility} \label{sec:c_compatibility}

Most if, not all, OS APIs are written in C.
CTwist, if it wants to be a compiled to native language, will require a simple and flexible way to 

\section{Twisted Standard Library}
  \subsection{Components}

Below is the list of Library Components in the Twisted Standard Library.
\begin{itemize}
  \item Algorithms: basic, widely applicable algorithms.
  \item Input/Output: I/O to/from numerous devices like GUI, files, and console.
  \item Math: extensive mathematical functionality framework
  \begin{itemize}
    \item Basic: basic math functions like \tcode{exp}, \tcode{sin}, \tcode{sqrt}, etc...
    \item Extended: Advanced math functions, in general terms derived from the Hypergeometric function, like \tcode{besselj}, \tcode{erf}, etc...
    \item String to function parsing, extendible with custom operators.
    \item Integration: Basic numerical integration routines.
  \end{itemize}
  \item Containers: various useful container classes
  \item Strings: UTF-8/16/32 strings and associated routines
  \item Concurrency
  \begin{itemize}
    \item Threads
    \item Mutex and other Concurrent control objects and functions...
  \end{itemize}
  \item File system: abstract view of the system's file system, useful to manipulate directory paths and open files.
  \item Signals
  \item GUI
  \item ...
\end{itemize}
Below is a detailed description of what each Component contains and how different Components can work together.
TODO

\section{Examples}
This section contains expressive and classic examples of programs and constructs often employed in tutorial or real programs and libraries.

  \subsection{Beginner-level examples}

    \subsubsection{``Hello World!"}

The classic first program a programmer meets whe learning a new language is without a doubt ``Hello World!".
It presents the minimal program structure and introduces a way to do textual output.
\begin{lstlisting}
entry
{
    std.io.print( "Hello World!" )
}
\end{lstlisting}
\lstinline|entry| is CTwist's version of the \lstinline|main| function in languages like C, C++, C\# or Java.
In contrast to other, more primitive languages, it takes no arguments under any circumstances.
It has no return type, and is not strictly a function that could be called in a devious manner.
A code block is surrounded by \tcode{\{} and \tcode{\}} and is used to designate several lines of code are to be seen as one entity.
A Twisted C statement does not have to end in a semicolon ``;", but it may.
A semicolon is useful if you want to stuff more than one statement on one line of code.
\tcode{std.io.output} is the fully qualified call to the \tcode{output} function in namespace \tcode{io} in namespace \tcode{std}, which designates the I/O Standard Library component.
The \tcode{std.io.output} function outputs to the Standard Output Device, which can be reseated by the programmer if deemed necessary.
An alternative version using the \tcode{import} keyword is written below, allowing the function call to be significantly simplified:
\begin{lstlisting}
import std.io
entry
{
    output( "Hello World!" )
}
\end{lstlisting}
Note that in building this program, absolutely no libraries need to be manually linked when producing an executable (they're not even mentioned "under the hood").
The \tcode{import} statement ensures that the resulting Twisted Object file contains a directive to pull in the \tcode{std.io} Library Component.
It also functions as a C-style \tcode{\#include}, pulling in all the functions and types in the Component \tcode{std.io}.

    \subsubsection{``Hello World!" in a file}

Instead of outputting the string to the Standard Output Device, the following program writes it to a file named \tcode{Hello World!.txt}.
\begin{lstlisting}
import std.io
entry
{
    file f = file.open( "Hello World!.txt" )
    f.output( "Hello World!" )
    f.close
}
\end{lstlisting}
In this program, \tcode{std.io} has once again been imported.
It includes basic file I/O, and a class called \tcode{file}, which (not surprisingly) represents a file in Twisted C.
The last line is not strictly necessary, as the file will get closed automatically when the object \tcode{f} goes out of scope at the closing \tcode{\}}.

    \subsubsection{``Hello From Thread!"}

The following program demonstrates the simplest of Concurrency features: a thread of execution.

  \subsection{Intermediate examples}
    \subsubsection{Calling C code}

  \subsection{Advanced examples}
    \subsubsection{None yet}

\end{document}